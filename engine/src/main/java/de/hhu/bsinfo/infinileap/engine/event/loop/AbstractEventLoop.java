package de.hhu.bsinfo.infinileap.engine.event.loop;

import lombok.extern.slf4j.Slf4j;
import org.agrona.hints.ThreadHints;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public abstract class AbstractEventLoop implements Runnable {

    /**
     * A reference on null which is set as the initial value for the current thread.
     */
    private static final Thread THREAD_NOT_SET = null;


    /**
     * Holds the thread running this event loop.
     */
    private final AtomicReference<Thread> currentThread = new AtomicReference<>(THREAD_NOT_SET);

    /**
     * Indicates if this event loop is running or not.
     */
    private boolean isRunning = false;

    private volatile EventLoopStatus status = EventLoopStatus.CREATED;

    @Override
    public void run() {

        isRunning = true;

        // Check if this is event loop has just started for the first time
        if (currentThread.compareAndSet(THREAD_NOT_SET, Thread.currentThread())) {

            // --
            //  1 - Initialize event loop
            // --

            try {
                onStart();
            } catch (Exception e) {
                log.error("Failed initializing event loop", e);
                status = EventLoopStatus.ERROR;
                return;
            }

            // --
            //  2 - Run event loop
            // --

            status = EventLoopStatus.RUNNING;
            while (isRunning) {
                executeEventLoop();
            }

            status = EventLoopStatus.STOPPED;


            // --
            //  3 - Release resources
            // --

            try {
                onStop();
            } catch (Exception e) {
                log.error("Failed cleaning up event loop", e);
                status = EventLoopStatus.ERROR;
                return;
            }

            status = EventLoopStatus.CLOSED;
        }
    }

    private void executeEventLoop() {
        try {
            onLoop();
        } catch (Exception e) {
            isRunning = false;
        }
    }

    protected void onStart() throws Exception {
        log.info("Starting event loop");
    }


    protected void onStop() throws Exception {
        log.info("Stopping event loop");
    }

    public final void waitOnStart() {
        while (status != EventLoopStatus.RUNNING) {
            ThreadHints.onSpinWait();
        }
    }

    public final void join() throws InterruptedException {
        var thread = currentThread.get();
        if (thread != null) {
            thread.join();
        }
    }

    /**
     * Returns this event loop's current status.
     */
    public final EventLoopStatus status() {
        return status;
    }

    /**
     * Starts the event loop on a thread generated by the provided thread factory.
     */
    public final void start(ThreadFactory threadFactory) {
        threadFactory.newThread(this).start();
    }

    protected abstract void onLoop() throws Exception;
}
